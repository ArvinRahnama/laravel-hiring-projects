1.Consider the following code:
use Illuminate\Support\Facades\Http; 
use Illuminate\Support\Facades\Queue;
Queue::XXX();
Http::XXX(function ($request) { return [];
});
You are conducting some tests and you don't want to send HTTP requests or send
jobs into the queue. What method should you write instead of xxx?


2.How to make Laravel event listeners queuable?

3.Consider the following components in a project:
    1. You use a global middleware, to append default parameters for the language key:
    <?php
    namespace App\Http\Middleware;
    class SetDefaultLanguageForUrls
    {
        public function handle ($request, Closure $next)
        {
            URL::defaults(['language' => 'en']);
            return $next($request);
        }
    }

    2. You have defined the following route for the article page:
    Route::prefix(' (language)')->group (function () { Route::get('article/{id}')->name('article.show');
    });

    2. In your articles.blade.php, you define the following links:
    <div>
        eforeach ($articles as $article)
        <a href="{{ route('article. show', ['language' => 'it', 'id' => {{ $article->name }}
        </a> @endforeach
    </div>

    Which URI will be generated in your Blade file for the article page with ID 1?

4.Write a query for joining Customer and Product tables with certain columns


5.Implement the function encodeplaintext($text)
It receives a text for example aaaabcccaaa
You must encode it by counting each consecutive sequense of letter for ex in aaaabccca there are : 
4 times the letter a
Then 1 b
Then 3 c
Theb 3 a
Therefore you must retutn string 4a1b3c3a 
Constraints:
Text is made of lower letter :a-z
Text is never null and has maximum lenght of 15000 characters 


6.The rephase function should return the string str without spaces and layed out in lines of at most n characters 
Example : rephase(3,”abc de fghij”)
Returns: 
abc
def
ghi
j
Example 2: rephase(2,”1 23 456”) 
Retunrs:
12
34
56
Write the body of the rephase function
Note :do not add a trailling \n character


7.sample payment code must be refactor to best practice of design pattern and clean code.
public function start(Request $request, Points $points, Payments $paymentModel)
{
    $id = $points->getOrinsert(Auth::user()->id, $request->cycleld);
    $validate= resolve(Provider1 PaymentValidateUserHandler::class, ['request' => new
    Provider1PaymentValidateUserRequest()])->handleRequest();
    if ($validate == = false) {
        return redirect(route('financial-factors-form', $request->cycleld));
    }
    
    $serial = resolve(Provider1 PaymentHandler::class, ['request' => new
    Provider1PaymentRequest($id)])->handleRequest();
    if ($serial == true) {
        $payment = $paymentModel->updateOrinsert('order_id', $id, ['order_id' => $id, 'total_amount'=> self::amount, 'serial' => $serial, 'user_id' => Auth::user()->id]);
        return view('payment.redirect_to_bank', [
        'order_id' => $id,
        'serial' => $serial,
        'postback_url' => route('callback', ['amount' => self::amount, 'order_id' => $id]),
        'payment_id' => is_object($payment) ? $payment->id: $payment
            ]);
    }
    return redirect(route('pay-form', $request->cycleld));
}

public function callback(Request $request, Points $points, Payments $paymentModel)
{
    $payment = $paymentModel->getByOrderid(Auth::user()->id, $request->order_id); 
    if (!$payment) {
        Session::flash('message', _('app.payment notfound')); 
        Session::flash('alert-class', 'alert-danger');
        return redirect(URL::previous());
    }
    $response = resolve(Provider1 PaymentStatusHandler::class, ['request': => new Provider1PaymentStatusRequest($request->order_id, $payment->serial)])->handleRequest();
    if (!$response) { 
        Session::flash('message', _('app.payment notfound'));
        Session::flash('alert-class', 'alert-danger');
        return redirect(URL::previous());
    }

    $paymentModel->edit($payment->id, ['gateway' => $response['gateway'], 'status' => $response['status'], 'total_amount' => $response['total_amount']]);
    if ($response['status'] == '6') {
        $points->edit($payment->order_id, ['payment_status' => Payments::PAYED]);
        return redirect(route('reciept', $point->cycle_id));
    }
    
    return redirect(URL::previous());
}

8.Implement closestTozero function to return the integer in the array $ints that is closest to zero
If there are two integers equally close to zero consider the positive element to be closer to zero (example:if $ints contains -5 and 5 return 5)
If $ints is empty, retun 0
Input: integers in $ints have values ranging from -2147483647 to 2147483647

9.We consider the sequence of numbers where a number is followed by the same number plus the sum of its digits 
two sequences which starts from different numbers may join at the given point for example the squence starting from 471 and the sequence starting from 480 share the number 519 the join point in their sequence 
Implement the function computeJoinPoint($s1,$s2)
You are guaranteed that the two sequences always join 
At a joining point lower than 20 000 000

Available ram:512MB
Timeout:6 seconds

10.Implement a sudoku game to check each row,column and squares